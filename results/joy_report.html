<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anna Gornyitzki, Cathy Fang, Johanna Jansen, Joy Chang, Lorretta Lu">
<meta name="dcterms.date" content="2025-10-19">

<title>Analysis of class surveys</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="joy_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="joy_report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="joy_report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="joy_report_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="joy_report_files/libs/quarto-html/popper.min.js"></script>
<script src="joy_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="joy_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="joy_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="joy_report_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="joy_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="joy_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="joy_report_files/libs/bootstrap/bootstrap-1fbf936f5d115924c956bdfb76a204f2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Analysis of class surveys</h1>
<p class="subtitle lead">Which courses are most strongly associated with higher programming comfort among students?</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Anna Gornyitzki, Cathy Fang, Johanna Jansen, Joy Chang, Lorretta Lu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 19, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive summary</h2>
<p>Joy’s portion of the analysis used random forest models to identify and rank the courses most strongly correlated with higher programming comfort. The analysis reveals that CS16, PSTAT 160, and PSTAT 122 are the most important predictors overall. Additionally, we find that this ranking of important courses differs significantly based on a student’s prior math proficiency, which will be elaborated in the Findings section.</p>
</section>
<section id="questions-of-interest" class="level2">
<h2 class="anchored" data-anchor-id="questions-of-interest">Questions of interest</h2>
<p>The analysis aimed to identify which courses were most strongly associated with students’ comfort in programming. Specifically, we addressed the following question:</p>
<blockquote class="blockquote">
<ol type="1">
<li><em>What are the top five courses that are most correlated with higher self-reported programming comfort among students?</em></li>
<li><em>Does math proficiency influence the ranking of the importance of courses as predictors for programming comfort? (explored using a random forest model)</em></li>
</ol>
</blockquote>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">Findings</h2>
<p>Summarize your results. Don’t try to explain every step you took; focus instead on providing the main data analytic outputs – tables and figures – and explaining clearly what they show. Clarify any important decisions you made in obtaining them. You can display codes if you like but it is not necessary.</p>
<section id="random-forest---joy" class="level3">
<h3 class="anchored" data-anchor-id="random-forest---joy">Random Forest - Joy</h3>
<section id="rq1-overall-course-importance" class="level4">
<h4 class="anchored" data-anchor-id="rq1-overall-course-importance">RQ1: Overall Course Importance</h4>
<p>First, we fit a model using the entire dataset to identify the courses with the strongest overall association with programming comfort. The “feature importance” score from the model measures the strength of this association. The chart below shows the top 10 most important courses.</p>
<p>It is worth noting that while feature importance reveals the strength of the relationship, it does not show the direction (i.e., whether taking the course is linked to higher or lower comfort). Therefore, the top courses shown below are only the most strongly correlated with programming comfort, but they may correlate with a higher or a lower degree of programming comfort. Despite this shortcoming, the feature importance of the random forest model has an advantage in being able to measure a predictor’s importance holistically, in the context of all other predictors. Unlike a simple correlation, which assesses only the isolated, bivariate linear relationship, the random forest’s non-linear structure accounts for interaction effects. This means the importance score of a course already reflects its conditional value, or how its contribution to programming comfort changes based on the presence or absence of other courses.</p>
<p>The top courses most strongly associated with programming comfort are CS 16, PSTAT 160, PSTAT 122, PSTAT 100, and PSTAT 131, which is reasonable since all of these courses except for 160 are programming-based. It is natural that the students who have taken these courses are more or less comfortable with programming, depending on their performance in and feelings for these courses.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Course</th>
<th style="text-align: right;">Importance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">CS16</td>
<td style="text-align: right;">0.133585</td>
</tr>
<tr class="even">
<td style="text-align: left;">PSTAT160</td>
<td style="text-align: right;">0.108485</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PSTAT122</td>
<td style="text-align: right;">0.0963313</td>
</tr>
<tr class="even">
<td style="text-align: left;">PSTAT100</td>
<td style="text-align: right;">0.0855638</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PSTAT131</td>
<td style="text-align: right;">0.0854055</td>
</tr>
</tbody>
</table>
<p><img src="random_forest_course_ranking.png" class="img-fluid"></p>
</section>
<section id="rq2-the-influence-of-math-proficiency" class="level4">
<h4 class="anchored" data-anchor-id="rq2-the-influence-of-math-proficiency">RQ2: The Influence of Math Proficiency</h4>
<p>To determine if the importance of courses changes based on a student’s background, we split the dataset into three groups: those with ‘advanced’ math proficiency, those with ‘intermediate’ proficiency, and those with ‘beginner’ proficiency.</p>
<p>We then ran the Random Forest analysis separately for each group. The subgroup whose math proficiency is ‘beginner’ is too small (n=3) to perform an analysis, so only the ‘advanced’ and ‘intermediate’ groups are kept and analyzed.</p>
<p>The comparison table below clearly shows how the ranking of the importance of courses as predictors for programming comfort changes when we take math proficiency into consideration. We can observe that CS 16, PSTAT 100, PSTAT 122, and PSTAT 160 remain the strongest predictors as in the overall course importance analysis. Their rankings change slightly - for example, PSTAT 100 becomes the most strongly correlated predictor for the group with intermediate math proficiency. Additionally, PSTAT 134, PSTAT 174, and CS 9 are included as the top predictors. These changes can be explained by the different learning paths for each group. For the ‘Math Intermediate’ students, foundational courses like PSTAT 100 and CS 9 are among the top predictors, as these courses establish the statistical and programming logic. Conversely, the ‘Math Advanced’ group, which already has this foundation, is more influenced by specialized, high-level courses like PSTAT 134 and PSTAT 174, although the foundational courses like CS 16 and PSTAT 122 are still highly important to them. This suggests that for advanced students, programming comfort is driven by applying their quantitative skills to more specific problems.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 20%">
<col style="width: 25%">
<col style="width: 20%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rank</th>
<th style="text-align: left;">Course (adv)</th>
<th style="text-align: right;">Importance (adv)</th>
<th style="text-align: left;">Course (int)</th>
<th style="text-align: right;">Importance (int)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: left;">CS16</td>
<td style="text-align: right;">0.157618</td>
<td style="text-align: left;">PSTAT100</td>
<td style="text-align: right;">0.144121</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: left;">PSTAT122</td>
<td style="text-align: right;">0.0982008</td>
<td style="text-align: left;">CS16</td>
<td style="text-align: right;">0.138668</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3</td>
<td style="text-align: left;">PSTAT134</td>
<td style="text-align: right;">0.0944759</td>
<td style="text-align: left;">CS9</td>
<td style="text-align: right;">0.103457</td>
</tr>
<tr class="even">
<td style="text-align: right;">4</td>
<td style="text-align: left;">PSTAT174</td>
<td style="text-align: right;">0.0862864</td>
<td style="text-align: left;">PSTAT122</td>
<td style="text-align: right;">0.0978085</td>
</tr>
<tr class="odd">
<td style="text-align: right;">5</td>
<td style="text-align: left;">PSTAT160</td>
<td style="text-align: right;">0.0859582</td>
<td style="text-align: left;">PSTAT160</td>
<td style="text-align: right;">0.0905109</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>